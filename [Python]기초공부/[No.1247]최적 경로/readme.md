문제 사이트 : https://swexpertacademy.com/main/code/problem/problemDetail.do

개발 환경 : pycham

문제 설명 :

※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

    삼성전자의 서비스 기사인 김대리는 회사에서 출발하여
    
    냉장고 배달을 위해 N명의 고객을 방문하고 자신의 집에 돌아가려한다.

    회사와 집의 위치, 그리고 각 고객의 위치는 이차원 정수 좌표 (x, y)로 주어지고
    
    (0 ≤ x ≤ 100, 0 ≤ y ≤ 100)

    두 위치 (x1, y1)와 (x2, y2) 사이의 거리는 |x1-x2| + |y1-y2|으로 계산된다.

    여기서 |x|는 x의 절대값을 의미하며 |3| = |-3| = 3이다. 회사의 좌표, 
    
    집의 좌표, 고객들의 좌표는 모두 다르다.

    회사에서 출발하여 N명의 고객을 모두 방문하고 집으로 돌아오는 경로 중 
    
    가장 짧은 것을 찾으려 한다.

    회사와 집의 좌표가 주어지고, 2명에서 10명 사이의 고객 좌표가 주어질 때,

    회사에서 출발해서 이들을 모두 방문하고 집에 돌아가는 경로 중 총 이동거리가 가장
    
    짧은 경로를 찾는 프로그램을 작성하라.

    여러분의 프로그램은 가장 짧은 경로의 이동거리만 밝히면 된다.

    이 문제는 가장 짧은 경로를 ‘효율적으로’ 찾는 것이 목적이 아니다.

    여러분은 모든 가능한 경로를 살펴서 해를 찾아도 좋다.

    모든 경우를 체계적으로 따질 수 있으면 정답을 맞출 수 있다.

[제약사항]

    고객의 수 N은 2≤N≤10 이다.

    그리고 회사의 좌표, 집의 좌표를 포함한 모든 N+2개의 좌표는 서로 다른 위치에 있으며 
    
    좌표의 값은 0이상 100 이하의 정수로 이루어진다.

[입력]

    가장 첫줄은 전체 테스트케이스의 수이다.

    이후, 두 줄에 테스트 케이스 하나씩이 차례로 주어진다.

    각 테스트 케이스의 첫째 줄에는 고객의 수 N이 주어진다. 
    
    둘째 줄에는 회사의 좌표,집의 좌표, N명의 고객의 좌표가 차례로 나열된다.

    좌표는 (x,y)쌍으로 구성되는데 입력에서는 x와 y가 공백으로 구분되어 제공된다.

[출력]

    총 10줄에 10개의 테스트 케이스 각각에 대한 답을 출력한다.

    각 줄은 ‘#x’로 시작하고 공백을 하나 둔 다음 최단 경로의 이동거리를 기록한다. 여기서 x는 테스트 케이스의 번호다.

입력

    10
    5
    0 0 100 100 70 40 30 10 10 5 90 70 50 20
    6
    88 81 85 80 19 22 31 15 27 29 30 10 20 26 5 14
    10
    39 9 97 61 35 93 62 64 96 39 36 36 9 59 59 96 61 7 64 43 43 58 1 36


출력

    #1 200
    #2 304
    #3 366


풀이 알고리즘

    회사의 좌표,집의 좌표,N개의 고객 좌표가 주어졌을 떄, 
    
    회사 -> N개 고객 방문 -> 집 의 경로 중 최단 경로를 찾는 문제였습니다.
    
    N개의 고객 방문을 통해 최단경로를 찾아내야 했으므로 dfs탐색이라고 생각하고 문제풀이를 진행하였습니다.
    
    회사-첫번째 고객 을 dfs시작값으로 지정하였고, dfs탐색 과정을 거쳐 최단거리값을 갱신하며
    
    모든 탐색이 끝났을 때, 최단거리를 출력하여 문제를 해결하였습니다.
    

구 현


    def dfs(count,idx,tot) :
        global ans
        if count == N :
            to_home = tot+abs(home[0]-arr[idx][0])+abs(home[1]-arr[idx][1])
            if to_home < ans :
                ans = to_home
            return
        else :
            for a in range(N) :
                if check[a] == 0 :
                    tt = tot + abs(arr[a][0]-arr[idx][0])+abs(arr[a][1]-arr[idx][1])
                    if tt < ans :
                        check[a] = 1
                        dfs(count+1,a,tt)
                        check[a] = 0


    T = int(input())

    for i in range(1,T+1) :

        arr = []

        N = int(input())
        temp = list(map(int,input().split()))

        leng = len(temp)
        
        # 회사 좌표
        office = (temp[0],temp[1])
        
        # 집의 좌표
        home = (temp[2],temp[3])
        
        # ans의 초기값은 최악의 경우로도 도달할 수 없는 거리값 세팅
        ans = 20000000
        
        # dfs탐색을 위해 방문확인을 하는 list타입의 check 변수
        check = [0 for _ in range(N)]

        for j in range(4,len(temp),2) :
            arr.append((temp[j],temp[j+1]))

        for j in range(N) :
            check[j] = 1
            dfs(1,j,abs(office[0]-arr[j][0])+abs(office[1]-arr[j][1]))
            check[j] = 0

        print('#'+str(i)+' '+str(ans))
