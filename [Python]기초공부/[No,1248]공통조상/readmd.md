문제 사이트 :

개발 환경 :

설명 :

※ SW Expert 아카데미의 문제를 무단 복제하는 것을 금지합니다.

    이진 트리에서 임의의 두 정점의 공통 조상 중 가장 가까운 것을 찾으려 한다.

    예를 들어, 아래의 이진 트리에서 정점 8과 13의 공통 조상은 정점 3와 1 두 개가 있다.

    이 중 8, 13에 가장 가까운 것은 정점 3이다.

    정점 3을 루트로 하는 서브 트리의 크기(서브 트리에 포함된 정점의 수)는 8이다.
 

![SW문제해결+응용 +3일차+-+공통조상_그림1](https://user-images.githubusercontent.com/57944215/179391047-cc339b18-7d08-48fb-9a69-12b053ee3a2f.png)


    임의의 이진 트리가 주어지고, 
    
    두 정점이 명시될 때 이들의 공통 조상 중 이들에 가장 가까운 정점을 찾고,
    
    그 정점을 루트로 하는 서브 트리의 크기를 알아내는 프로그램을 작성하라.

    입력에서 주어지는 두 정점이 서로 조상과 자손 관계인 경우는 없다.

    위의 트리에서 예를 든다면 두 정점이 “11과 3”과 같이 주어지는 경우는 없다.

[입력]

    가장 첫줄은 전체 테스트케이스의 수이다.

    10개의 테스트 케이스가 주어진다.

    두 줄이 하나의 테스트 케이스가 되며, 따라서 전체 입력은 20줄로 이루어진다.

    각 케이스의 첫줄에는 트리의 정점의 총 수 V와 간선의 총 수 E,
    
    공통 조상을 찾는 두 개의 정점 번호가 주어진다 (정점의 수 V는 10 ≤ V ≤ 10000 이다). 

    그 다음 줄에는 E개 간선이 나열된다. 간선은 간선을 이루는 두 정점으로, 
    
    항상 “부모 자식” 순서로 표기된다.

    위에서 예로 든 트리에서 정점 5와 8을 잇는 간선은 “5 8”로 표기되고,
    
    절대로 “8 5”와 같이 표기되지는 않는다.

    간선이 입력되는 순서는 정해져 있지 않다. 입력에서 이웃한 수는 모두 공백으로 구분된다.

    정점의 번호는 1부터 V까지의 정수이며, 
    
    전체 트리에서 루트가 되는 정점은 항상 1번으로 표기된다.

    부모 정점이 자식 정점보다 항상 번호가 작은 것은 아니다. 
    
    즉, 40번 정점이 20번 정점의 부모가 될 수도 있다.

    이 문제에서 자식 정점이 부모 정점의 왼쪽 자식인지 오른쪽 자식인지는 중요하지 않다.

[출력]

    총 10줄에 10개의 테스트 케이스 각각에 대한 답을 출력한다.

    각 줄은 테스트 케이스의 번호를 의미하는 ‘#x’로 시작하고 공백을 하나 둔 다음 답을 기록한다.

    답은 공통조상 중 가장 가까운 것의 번호, 
    
    그것을 루트로 하는 서브 트리의 크기를 뜻하는 2개의 정수로 구성된다. 
    
    이 두 정수는 공백으로 구분한다.

입력

    10
    13 12 8 13
    1 2 1 3 2 4 3 5 3 6 4 7 7 12 5 9 5 8 6 10 6 11 11 13
    10 9 2 10
    1 2 1 3 3 4 4 5 5 6 6 7 7 8 8 9 9 10


출력

    #1 3 8
    #2 1 10
    
풀이 알고리즘

    주어진 이진트리의 정보와, 정해진 두 노드를 이용하여 노드들의 공통조상 중 가장 가까운 것을 찾아내고
    공통조상이 가지고 있는 서브트리의 노드 갯수의 합을 출력하는 문제였습니다.
    
    제가 생각한 알고리즘의 기본 틀은 다음과 같습니다
    
    1. 입력된 정보를 바탕으로 특정 노드 N의 자식을 저장하는 list 타입의 변수 child 와 부모를 저장하는
    
    list타입의 변수 parent 선언
    
    2. 선언된 parent를 이용하여 정해진 두 노드 n1,n2 부터 루트노드까지 가는 경로를 저장하는
    
    list 생성
    
    3. 생성된 list를 사용하여 두 노드의 공통 조상 중 가장 가까운 공통 노드 찾기
    
    4. (3)에서 찾은 노드 기준으로 서브트리를 bfs탐색으로 진행하며 갯수 구하기
    
    글로 설명하면 더 헷갈리므로 코드에 주석을 덧붙여 설명하겠습니다.
    


구 현

    from collections import deque

    T = int(input())

    for i in range(1, T + 1):

        # 2차원 list타입의 변수 child -> 특정노드 a가 주어졌을 때 a의 자식노드가 child[a].append() 메소드를 사용하여 추가될 예정
        child = [[] for _ in range(10001)] 
        
        ''' 1차원 list타입의 변수 parent -> 특정 노드 a가 주어졌을 떄, a의 부모노드를 저장하는 변수, 한 노드당 부모노드는 하나만 존재하므로
         1차원 배열로 선언'''
        parent = [0 for _ in range(10001)]
        
        # 입력값 V => 노드의 수 E=> 간선의 수 n1 => 공통노드를 찾는데 사용될 첫번째 노드 n2 => 공통노드를 찾는데 사용될 두번째 노드
        V, E, n1, n2 = map(int, input().split())

        # 간선의 입력을 한줄로 받은 뒤 임시로 저장하는 list
        temp = list(map(int, input().split()))
        
        
        # 입력된 간선의 정보를 바탕으로 child,parent 의 내용 추가
        for a in range(0, len(temp), 2):
            child[temp[a]].append(temp[a + 1])
            parent[temp[a + 1]] = temp[a]

        n1_parent = []
        n2_parent = []
        c = n1
        
        # n1의 부모노드를 찾아 n1_parent에 append하는 while문. 루트노드인 1까지 탐색진행
        while (1):
            n1_parent.append(parent[c])
            c = parent[c]
            if c == 1:
                n1_parent.append(1)
                break

        c = n2
        # n2의 부모노드를 찾아 n2_parent에 append하는 while문. 루트노드인 1까지 탐색진행
        while (1):
            n2_parent.append(parent[c])
            c = parent[c]
            if c == 1:
                n2_parent.append(1)
                break

        idx_1 = len(n1_parent) - 1
        idx_2 = len(n2_parent) - 1
        common_node = 1
        
        # 모든 노드의 부모노드의 시작은 1, 부모노드를 저장한 n1_parent,n2_parent의 끝값은 1.
        # n1_parent와 n2_parent를 끝에서부터 비교하며 값이 달라지는 시점을 찾아내고, 달라지기 직전의 값을 공통노드로 설정
        # 문제의 첫번째 조건인 [ 공통노드 ] 찾기 완료
        while (idx_1 >= 0 and idx_2 >= 0):
            if n1_parent[idx_1] != n2_parent[idx_2]:
                common_node = n1_parent[idx_1 + 1]
                break
            idx_1 -= 1
            idx_2 -= 1
            
        # 문제의 두번째 조건인 공통노드의 서브트리노드 갯수 출력
        
        # 탐색의 시작은 공통노드부터 시작하고, 모든 서브트리를 탐색할 예정이므로 queue에 집어넣어 bfs탐색 실시
        queue = deque()
        queue.append(common_node)


        #서브트리의 갯수는 본인 포함이므로 answer 은 1부터 시작
        answer = 1
        
        
        while (len(queue) != 0):
        
            size = len(queue)
            # 현재 단계의 queue사이즈만큼 for문을 반복하여 모든 서브트리 탐색
            for a in range(size):
                num = queue.popleft()
                
                # 현재 방문한 서브트리노드의 자식노드를 찾고, queue에 append
                # 서브트리의 자식노드를 찾아내었으므로 answer += 1
                for b in child[num]:
                    queue.append(b)
                    answer += 1
                    
        # 공통노드인 common_node와 서브트리노드의 갯수인 answer 출력
        print('#' + str(i) + ' ' + str(common_node) + ' ' + str(answer))
    
